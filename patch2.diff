From 55f2b84c5bc8700089fcadbd320e9f91cf4a824d Mon Sep 17 00:00:00 2001
From: klaus triendl <klaus@triendl.eu>
Date: Sat, 23 Apr 2022 23:21:17 +0300
Subject: [PATCH] Code quality (clearer code), included dependent headers

* Removed some unnecessary constructors that are just forwarding their arguments to initialize members
* Qualify enum values by their original enum class name instead of using `decltype`
* Spelled out type for SQLite database connection instead of using `auto`
* Moved `storage_t<>::drop_trigger()` to base class `storage_base`, changed signature to accept a `std::string`
---
 dev/alias.h                               |  4 --
 dev/column_names_getter.h                 |  1 +
 dev/conditions.h                          |  5 --
 dev/constraints.h                         | 31 ++++------
 dev/error_code.h                          |  2 +-
 dev/function.h                            |  2 +-
 dev/implementations/storage_definitions.h | 19 +++---
 dev/iterator.h                            |  2 +-
 dev/pragma.h                              | 15 ++---
 dev/start_macros.h                        |  4 ++
 dev/statement_finalizer.h                 |  2 +-
 dev/storage.h                             | 75 ++++++++++-------------
 dev/storage_base.h                        | 41 +++++++------
 dev/table_info.h                          |  4 ++
 dev/view.h                                |  3 +-
 15 files changed, 99 insertions(+), 111 deletions(-)

diff --git a/dev/alias.h b/dev/alias.h
index bb60062..ee44fcc 100644
--- a/dev/alias.h
+++ b/dev/alias.h
@@ -36,10 +36,6 @@ namespace sqlite_orm {
             using column_type = C;
 
             column_type column;
-
-            alias_column_t() {}
-
-            alias_column_t(column_type column_) : column(std::move(column_)) {}
         };
 
         template<class T, class SFINAE = void>
diff --git a/dev/column_names_getter.h b/dev/column_names_getter.h
index 2531428..7f2d5b6 100644
--- a/dev/column_names_getter.h
+++ b/dev/column_names_getter.h
@@ -6,6 +6,7 @@
 #include <functional>  //  std::reference_wrapper
 
 #include "error_code.h"
+#include "serializer_context.h"
 #include "select_constraints.h"
 #include "util.h"
 
diff --git a/dev/conditions.h b/dev/conditions.h
index c464719..20641bc 100644
--- a/dev/conditions.h
+++ b/dev/conditions.h
@@ -421,11 +421,6 @@ namespace sqlite_orm {
         struct order_by_base {
             int asc_desc = 0;  //  1: asc, -1: desc
             std::string _collate_argument;
-
-            order_by_base() = default;
-
-            order_by_base(decltype(asc_desc) asc_desc_, decltype(_collate_argument) _collate_argument_) :
-                asc_desc(asc_desc_), _collate_argument(move(_collate_argument_)) {}
         };
 
         struct order_by_string {
diff --git a/dev/constraints.h b/dev/constraints.h
index c3563c4..180379c 100644
--- a/dev/constraints.h
+++ b/dev/constraints.h
@@ -131,22 +131,22 @@ namespace sqlite_orm {
 
         inline std::ostream& operator<<(std::ostream& os, foreign_key_action action) {
             switch(action) {
-                case decltype(action)::no_action:
+                case foreign_key_action::no_action:
                     os << "NO ACTION";
                     break;
-                case decltype(action)::restrict_:
+                case foreign_key_action::restrict_:
                     os << "RESTRICT";
                     break;
-                case decltype(action)::set_null:
+                case foreign_key_action::set_null:
                     os << "SET NULL";
                     break;
-                case decltype(action)::set_default:
+                case foreign_key_action::set_default:
                     os << "SET DEFAULT";
                     break;
-                case decltype(action)::cascade:
+                case foreign_key_action::cascade:
                     os << "CASCADE";
                     break;
-                case decltype(action)::none:
+                case foreign_key_action::none:
                     break;
             }
             return os;
@@ -229,7 +229,7 @@ namespace sqlite_orm {
             }
 
             operator bool() const {
-                return this->_action != decltype(this->_action)::none;
+                return this->_action != foreign_key_action::none;
             }
         };
 
@@ -301,8 +301,6 @@ namespace sqlite_orm {
 
             tuple_type columns;
 
-            foreign_key_intermediate_t(tuple_type columns_) : columns(std::move(columns_)) {}
-
             template<class... Rs>
             foreign_key_t<std::tuple<Cs...>, std::tuple<Rs...>> references(Rs... refs) {
                 return {std::move(this->columns), std::make_tuple(std::forward<Rs>(refs)...)};
@@ -311,22 +309,19 @@ namespace sqlite_orm {
 #endif
 
         struct collate_constraint_t {
-            internal::collate_argument argument = internal::collate_argument::binary;
-
-            collate_constraint_t(internal::collate_argument argument_) : argument(argument_) {}
+            collate_argument argument = collate_argument::binary;
 
             operator std::string() const {
-                std::string res = "COLLATE " + this->string_from_collate_argument(this->argument);
-                return res;
+                return "COLLATE " + this->string_from_collate_argument(this->argument);
             }
 
-            static std::string string_from_collate_argument(internal::collate_argument argument) {
+            static std::string string_from_collate_argument(collate_argument argument) {
                 switch(argument) {
-                    case decltype(argument)::binary:
+                    case collate_argument::binary:
                         return "BINARY";
-                    case decltype(argument)::nocase:
+                    case collate_argument::nocase:
                         return "NOCASE";
-                    case decltype(argument)::rtrim:
+                    case collate_argument::rtrim:
                         return "RTRIM";
                 }
                 throw std::system_error{orm_error_code::invalid_collate_argument_enum};
diff --git a/dev/error_code.h b/dev/error_code.h
index 4eda9df..e63691a 100644
--- a/dev/error_code.h
+++ b/dev/error_code.h
@@ -1,8 +1,8 @@
 #pragma once
 
+#include <sqlite3.h>
 #include <system_error>  // std::error_code, std::system_error
 #include <string>  //  std::string
-#include <sqlite3.h>
 #include <stdexcept>
 #include <sstream>  //  std::ostringstream
 #include <type_traits>
diff --git a/dev/function.h b/dev/function.h
index 1e1184e..ab326a4 100644
--- a/dev/function.h
+++ b/dev/function.h
@@ -1,12 +1,12 @@
 #pragma once
 
+#include <sqlite3.h>
 #include <type_traits>
 #include <string>  //  std::string
 #include <tuple>  //  std::tuple
 #include <functional>  //  std::function
 #include <algorithm>  //  std::min
 #include <cstddef>
-#include <sqlite3.h>
 
 #include "cxx_polyfill.h"
 
diff --git a/dev/implementations/storage_definitions.h b/dev/implementations/storage_definitions.h
index 766fe1d..9d38d94 100644
--- a/dev/implementations/storage_definitions.h
+++ b/dev/implementations/storage_definitions.h
@@ -4,6 +4,9 @@
  */
 #pragma once
 #include <type_traits>  //  std::is_same
+#include <sstream>
+#include <functional>  //  std::reference_wrapper, std::cref
+#include <algorithm>  //  std::find_if
 
 #include "../storage.h"
 #include "../dbstat.h"
@@ -26,10 +29,10 @@ namespace sqlite_orm {
             auto res = sync_schema_result::already_in_sync;
 
             auto schema_stat = this->schema_status(tImpl, db, preserve);
-            if(schema_stat != decltype(schema_stat)::already_in_sync) {
-                if(schema_stat == decltype(schema_stat)::new_table_created) {
+            if(schema_stat != sync_schema_result::already_in_sync) {
+                if(schema_stat == sync_schema_result::new_table_created) {
                     this->create_table(db, tImpl.table.name, tImpl);
-                    res = decltype(res)::new_table_created;
+                    res = sync_schema_result::new_table_created;
                 } else {
                     if(schema_stat == sync_schema_result::old_columns_removed ||
                        schema_stat == sync_schema_result::new_columns_added ||
@@ -51,11 +54,11 @@ namespace sqlite_orm {
                             for(auto& tableInfo: dbTableInfo) {
                                 this->drop_column(db, tImpl.table.name, tableInfo.name);
                             }
-                            res = decltype(res)::old_columns_removed;
+                            res = sync_schema_result::old_columns_removed;
 #else
                             //  extra table columns than storage columns
                             this->backup_table(db, tImpl, {});
-                            res = decltype(res)::old_columns_removed;
+                            res = sync_schema_result::old_columns_removed;
 #endif
                         }
 
@@ -68,19 +71,19 @@ namespace sqlite_orm {
                                     this->add_column(tImpl.table.name, column, db);
                                 });
                             }
-                            res = decltype(res)::new_columns_added;
+                            res = sync_schema_result::new_columns_added;
                         }
 
                         if(schema_stat == sync_schema_result::new_columns_added_and_old_columns_removed) {
 
                             // remove extra columns
                             this->backup_table(db, tImpl, columnsToAdd);
-                            res = decltype(res)::new_columns_added_and_old_columns_removed;
+                            res = sync_schema_result::new_columns_added_and_old_columns_removed;
                         }
                     } else if(schema_stat == sync_schema_result::dropped_and_recreated) {
                         this->drop_table_internal(tImpl.table.name, db);
                         this->create_table(db, tImpl.table.name, tImpl);
-                        res = decltype(res)::dropped_and_recreated;
+                        res = sync_schema_result::dropped_and_recreated;
                     }
                 }
             }
diff --git a/dev/iterator.h b/dev/iterator.h
index ee9e4c5..a06bf10 100644
--- a/dev/iterator.h
+++ b/dev/iterator.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <memory>  //  std::shared_ptr, std::unique_ptr, std::make_shared
 #include <sqlite3.h>
+#include <memory>  //  std::shared_ptr, std::unique_ptr, std::make_shared
 #include <type_traits>  //  std::decay
 #include <utility>  //  std::move
 #include <cstddef>  //  std::ptrdiff_t
diff --git a/dev/pragma.h b/dev/pragma.h
index 906efb2..2210f8c 100644
--- a/dev/pragma.h
+++ b/dev/pragma.h
@@ -1,10 +1,11 @@
 #pragma once
 
-#include <string>  //  std::string
 #include <sqlite3.h>
+#include <string>  //  std::string
 #include <functional>  //  std::function
 #include <memory>  // std::shared_ptr
 #include <vector>  //  std::vector
+#include <sstream>
 
 #include "error_code.h"
 #include "util.h"
@@ -119,7 +120,7 @@ namespace sqlite_orm {
 
             std::vector<sqlite_orm::table_info> table_info(const std::string& tableName) const {
                 auto connection = this->get_connection();
-                auto db = connection.get();
+                sqlite3* db = connection.get();
 
                 std::vector<sqlite_orm::table_info> result;
                 auto query = "PRAGMA table_info(" + quote_identifier(tableName) + ")";
@@ -135,9 +136,9 @@ namespace sqlite_orm {
                             std::string type = argv[index++];
                             bool notnull = !!std::atoi(argv[index++]);
                             std::string dflt_value = argv[index] ? argv[index] : "";
-                            index++;
+                            ++index;
                             auto pk = std::atoi(argv[index++]);
-                            res.emplace_back(cid, name, type, notnull, dflt_value, pk);
+                            res.emplace_back(cid, move(name), move(type), notnull, move(dflt_value), pk);
                         }
                         return 0;
                     },
@@ -159,9 +160,9 @@ namespace sqlite_orm {
             template<class T>
             T get_pragma(const std::string& name) {
                 auto connection = this->get_connection();
+                sqlite3* db = connection.get();
                 auto query = "PRAGMA " + name;
                 T result;
-                auto db = connection.get();
                 auto rc = sqlite3_exec(db, query.c_str(), getPragmaCallback<T>, &result, nullptr);
                 if(rc == SQLITE_OK) {
                     return result;
@@ -182,7 +183,7 @@ namespace sqlite_orm {
                 }
                 std::stringstream ss;
                 ss << "PRAGMA " << name << " = " << value;
-                internal::perform_void_exec(db, ss.str());
+                perform_void_exec(db, ss.str());
             }
 
             void set_pragma(const std::string& name, const sqlite_orm::journal_mode& value, sqlite3* db = nullptr) {
@@ -192,7 +193,7 @@ namespace sqlite_orm {
                 }
                 std::stringstream ss;
                 ss << "PRAGMA " << name << " = " << internal::to_string(value);
-                internal::perform_void_exec(db, ss.str());
+                perform_void_exec(db, ss.str());
             }
         };
     }
diff --git a/dev/start_macros.h b/dev/start_macros.h
index cb36ce3..a4a4308 100644
--- a/dev/start_macros.h
+++ b/dev/start_macros.h
@@ -35,6 +35,10 @@ __pragma(push_macro("max"))
 #define SQLITE_ORM_CONSTEVAL constexpr
 #endif
 
+#if __cpp_aggregate_paren_init >= 201902L
+#define SQLITE_ORM_AGGREGATE_PAREN_INIT
+#endif
+
 #if __cplusplus >= 201703L  // C++17 or later
 #if __has_include(<optional>)
 #define SQLITE_ORM_OPTIONAL_SUPPORTED
diff --git a/dev/statement_finalizer.h b/dev/statement_finalizer.h
index c1cf9af..d949500 100644
--- a/dev/statement_finalizer.h
+++ b/dev/statement_finalizer.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <memory>  // std::unique_ptr
 #include <sqlite3.h>
+#include <memory>  // std::unique_ptr
 #include <type_traits>  // std::integral_constant
 
 namespace sqlite_orm {
diff --git a/dev/storage.h b/dev/storage.h
index ecf3d15..69168d6 100644
--- a/dev/storage.h
+++ b/dev/storage.h
@@ -1,9 +1,9 @@
 #pragma once
 
+#include <sqlite3.h>
 #include <memory>  //  std::unique/shared_ptr, std::make_unique/shared
 #include <system_error>  //  std::system_error
 #include <string>  //  std::string
-#include <sqlite3.h>
 #include <type_traits>  //  std::remove_reference, std::is_base_of, std::decay, std::false_type, std::true_type
 #include <cstddef>  //  std::ptrdiff_t
 #include <iterator>  //  std::input_iterator_tag, std::iterator_traits, std::distance
@@ -213,16 +213,6 @@ namespace sqlite_orm {
             }
 
           public:
-            template<class T>
-            void drop_trigger(const T& triggerName) {
-                std::stringstream ss;
-                ss << "DROP TRIGGER " << quote_identifier(triggerName);
-                auto query = ss.str();
-                auto con = this->get_connection();
-                auto db = con.get();
-                perform_void_exec(db, query);
-            }
-
             template<class T, class... Args>
             view_t<T, self, Args...> iterate(Args&&... args) {
                 this->assert_mapped_type<T>();
@@ -858,17 +848,17 @@ namespace sqlite_orm {
                             // extra table columns than storage columns
                             if(!preserve) {
 #if SQLITE_VERSION_NUMBER >= 3035000  //  DROP COLUMN feature exists (v3.35.0)
-                                res = decltype(res)::old_columns_removed;
+                                res = sync_schema_result::old_columns_removed;
 #else
                                 gottaCreateTable = true;
 #endif
                             } else {
-                                res = decltype(res)::old_columns_removed;
+                                res = sync_schema_result::old_columns_removed;
                             }
                         }
                     }
                     if(gottaCreateTable) {
-                        res = decltype(res)::dropped_and_recreated;
+                        res = sync_schema_result::dropped_and_recreated;
                     } else {
                         if(!columnsToAdd.empty()) {
                             // extra storage columns than table columns
@@ -889,22 +879,22 @@ namespace sqlite_orm {
                                 }
                             }
                             if(!gottaCreateTable) {
-                                if(res == decltype(res)::old_columns_removed) {
-                                    res = decltype(res)::new_columns_added_and_old_columns_removed;
+                                if(res == sync_schema_result::old_columns_removed) {
+                                    res = sync_schema_result::new_columns_added_and_old_columns_removed;
                                 } else {
-                                    res = decltype(res)::new_columns_added;
+                                    res = sync_schema_result::new_columns_added;
                                 }
                             } else {
-                                res = decltype(res)::dropped_and_recreated;
+                                res = sync_schema_result::dropped_and_recreated;
                             }
                         } else {
-                            if(res != decltype(res)::old_columns_removed) {
-                                res = decltype(res)::already_in_sync;
+                            if(res != sync_schema_result::old_columns_removed) {
+                                res = sync_schema_result::already_in_sync;
                             }
                         }
                     }
                 } else {
-                    res = decltype(res)::new_table_created;
+                    res = sync_schema_result::new_table_created;
                 }
                 return res;
             }
@@ -951,8 +941,8 @@ namespace sqlite_orm {
             template<typename S>
             prepared_statement_t<S> prepare_impl(S statement) {
                 auto con = this->get_connection();
+                sqlite3* db = con.get();
                 sqlite3_stmt* stmt;
-                auto db = con.get();
                 using context_t = serializer_context<impl_type>;
                 context_t context{this->impl};
                 context.skip_table_name = false;
@@ -995,8 +985,8 @@ namespace sqlite_orm {
              */
             std::map<std::string, sync_schema_result> sync_schema(bool preserve = false) {
                 auto con = this->get_connection();
+                sqlite3* db = con.get();
                 std::map<std::string, sync_schema_result> result;
-                auto db = con.get();
                 this->impl.for_each([&result, db, preserve, this](auto& storageImpl) {
                     auto res = this->sync_table(storageImpl, db, preserve);
                     result.insert({storageImpl.table.name, res});
@@ -1011,8 +1001,8 @@ namespace sqlite_orm {
              */
             std::map<std::string, sync_schema_result> sync_schema_simulate(bool preserve = false) {
                 auto con = this->get_connection();
+                sqlite3* db = con.get();
                 std::map<std::string, sync_schema_result> result;
-                auto db = con.get();
                 this->impl.for_each([&result, db, preserve, this](auto& tableImpl) {
                     auto schemaStatus = this->schema_status(tableImpl, db, preserve);
                     result.insert({tableImpl.table.name, schemaStatus});
@@ -1143,7 +1133,7 @@ namespace sqlite_orm {
             template<class... Args>
             void execute(const prepared_statement_t<replace_raw_t<Args...>>& statement) {
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 sqlite3_reset(stmt);
                 auto index = 1;
@@ -1160,7 +1150,7 @@ namespace sqlite_orm {
             template<class... Args>
             void execute(const prepared_statement_t<insert_raw_t<Args...>>& statement) {
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 sqlite3_reset(stmt);
                 auto index = 1;
@@ -1181,13 +1171,12 @@ namespace sqlite_orm {
                 using object_type = typename expression_object_type<expression_type>::type;
                 auto index = 1;
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto& tImpl = this->get_impl<object_type>();
-                auto& object = statement.expression.obj;
                 sqlite3_reset(stmt);
                 iterate_tuple(statement.expression.columns.columns,
-                              [&object, &index, &stmt, &tImpl, db](auto& memberPointer) {
+                              [&object = statement.expression.obj, &index, &stmt, &tImpl, db](auto& memberPointer) {
                                   using column_type = std::decay_t<decltype(memberPointer)>;
                                   using field_type = column_result_of_t<self, column_type>;
                                   const auto* value =
@@ -1212,7 +1201,7 @@ namespace sqlite_orm {
                 auto& tImpl = this->get_impl<object_type>();
                 auto index = 1;
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 sqlite3_reset(stmt);
 
@@ -1260,7 +1249,7 @@ namespace sqlite_orm {
                 using object_type = typename expression_object_type<expression_type>::type;
                 auto index = 1;
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto& tImpl = this->get_impl<object_type>();
                 sqlite3_reset(stmt);
@@ -1306,7 +1295,7 @@ namespace sqlite_orm {
             template<class T, class... Ids>
             void execute(const prepared_statement_t<remove_t<T, Ids...>>& statement) {
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1325,7 +1314,7 @@ namespace sqlite_orm {
                 using expression_type = typename statement_type::expression_type;
                 using object_type = typename expression_object_type<expression_type>::type;
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto& tImpl = this->get_impl<object_type>();
                 auto stmt = statement.stmt;
                 auto index = 1;
@@ -1365,7 +1354,7 @@ namespace sqlite_orm {
             std::unique_ptr<T> execute(const prepared_statement_t<get_pointer_t<T, Ids...>>& statement) {
                 auto& tImpl = this->get_impl<T>();
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1397,7 +1386,7 @@ namespace sqlite_orm {
             std::optional<T> execute(const prepared_statement_t<get_optional_t<T, Ids...>>& statement) {
                 auto& tImpl = this->get_impl<T>();
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1429,7 +1418,7 @@ namespace sqlite_orm {
             T execute(const prepared_statement_t<get_t<T, Ids...>>& statement) {
                 auto& tImpl = this->get_impl<T>();
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1459,7 +1448,7 @@ namespace sqlite_orm {
             template<class T, class... Args>
             void execute(const prepared_statement_t<remove_all_t<T, Args...>>& statement) {
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1476,7 +1465,7 @@ namespace sqlite_orm {
             template<class... Args, class... Wargs>
             void execute(const prepared_statement_t<update_all_t<set_t<Args...>, Wargs...>>& statement) {
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1502,7 +1491,7 @@ namespace sqlite_orm {
             template<class T, class... Args, class R = column_result_of_t<self, T>>
             std::vector<R> execute(const prepared_statement_t<select_t<T, Args...>>& statement) {
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1541,7 +1530,7 @@ namespace sqlite_orm {
             R execute(const prepared_statement_t<get_all_t<T, R, Args...>>& statement) {
                 auto& tImpl = this->get_impl<T>();
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1577,7 +1566,7 @@ namespace sqlite_orm {
             R execute(const prepared_statement_t<get_all_pointer_t<T, R, Args...>>& statement) {
                 auto& tImpl = this->get_impl<T>();
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1614,7 +1603,7 @@ namespace sqlite_orm {
             R execute(const prepared_statement_t<get_all_optional_t<T, R, Args...>>& statement) {
                 auto& tImpl = this->get_impl<T>();
                 auto con = this->get_connection();
-                auto db = con.get();
+                sqlite3* db = con.get();
                 auto stmt = statement.stmt;
                 auto index = 1;
                 sqlite3_reset(stmt);
@@ -1679,8 +1668,8 @@ namespace sqlite_orm {
                             auto query = ss.str();
                             ss.flush();
                             auto con = this->get_connection();
+                            sqlite3* db = con.get();
                             sqlite3_stmt* stmt;
-                            auto db = con.get();
                             if(sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr) == SQLITE_OK) {
                                 statement_finalizer finalizer(stmt);
                                 columnIndex = 1;
diff --git a/dev/storage_base.h b/dev/storage_base.h
index 6131669..a98fb81 100644
--- a/dev/storage_base.h
+++ b/dev/storage_base.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <functional>  //  std::function, std::bind
 #include <sqlite3.h>
+#include <functional>  //  std::function, std::bind
 #include <string>  //  std::string
 #include <sstream>  //  std::stringstream
 #include <utility>  //  std::move
@@ -10,13 +10,11 @@
 #include <memory>  //  std::make_shared, std::shared_ptr
 #include <map>  //  std::map
 #include <type_traits>  //  std::decay, std::is_same
-#include <algorithm>  //  std::iter_swap
 
 #include "pragma.h"
 #include "limit_accesor.h"
 #include "transaction_guard.h"
 #include "statement_finalizer.h"
-#include "type_printer.h"
 #include "tuple_helper/tuple_helper.h"
 #include "row_extractor.h"
 #include "util.h"
@@ -47,19 +45,24 @@ namespace sqlite_orm {
             void drop_index(const std::string& indexName) {
                 std::stringstream ss;
                 ss << "DROP INDEX " << quote_identifier(indexName);
-                perform_void_exec(get_connection().get(), ss.str());
+                perform_void_exec(this->get_connection().get(), ss.str());
+            }
+
+            void drop_trigger(const std::string& triggerName) {
+                std::stringstream ss;
+                ss << "DROP TRIGGER " << quote_identifier(triggerName);
+                perform_void_exec(this->get_connection().get(), ss.str());
             }
 
             void vacuum() {
-                perform_void_exec(get_connection().get(), "VACUUM");
+                perform_void_exec(this->get_connection().get(), "VACUUM");
             }
 
             /**
              *  Drops table with given name.
              */
             void drop_table(const std::string& tableName) {
-                auto con = this->get_connection();
-                this->drop_table_internal(tableName, con.get());
+                this->drop_table_internal(tableName, this->get_connection().get());
             }
 
             /**
@@ -68,7 +71,7 @@ namespace sqlite_orm {
             void rename_table(const std::string& from, const std::string& to) {
                 std::stringstream ss;
                 ss << "ALTER TABLE " << quote_identifier(from) << " RENAME TO " << quote_identifier(to);
-                perform_void_exec(get_connection().get(), ss.str());
+                perform_void_exec(this->get_connection().get(), ss.str());
             }
 
             /**
@@ -140,10 +143,10 @@ namespace sqlite_orm {
              */
             std::vector<std::string> table_names() {
                 auto con = this->get_connection();
+                sqlite3* db = con.get();
                 std::vector<std::string> tableNames;
                 std::string sql = "SELECT name FROM sqlite_master WHERE type='table'";
                 using data_t = std::vector<std::string>;
-                auto db = con.get();
                 int res = sqlite3_exec(
                     db,
                     sql.c_str(),
@@ -191,7 +194,7 @@ namespace sqlite_orm {
              */
             template<class F>
             void create_scalar_function() {
-                static_assert(is_scalar_function<F>::value, "F cannot be a scalar function");
+                static_assert(is_scalar_function<F>::value, "F can't be an aggregate function");
 
                 std::stringstream ss;
                 ss << F::name();
@@ -221,7 +224,7 @@ namespace sqlite_orm {
                 });
 
                 if(this->connection->retain_count() > 0) {
-                    auto db = this->connection->get();
+                    sqlite3* db = this->connection->get();
                     try_to_create_function(db,
                                            static_cast<user_defined_scalar_function_t&>(*this->scalarFunctions.back()));
                 }
@@ -252,7 +255,7 @@ namespace sqlite_orm {
              */
             template<class F>
             void create_aggregate_function() {
-                static_assert(is_aggregate_function<F>::value, "F cannot be an aggregate function");
+                static_assert(is_aggregate_function<F>::value, "F can't be a scalar function");
 
                 std::stringstream ss;
                 ss << F::name();
@@ -288,7 +291,7 @@ namespace sqlite_orm {
                 });
 
                 if(this->connection->retain_count() > 0) {
-                    auto db = this->connection->get();
+                    sqlite3* db = this->connection->get();
                     try_to_create_function(
                         db,
                         static_cast<user_defined_aggregate_function_t&>(*this->aggregateFunctions.back()));
@@ -328,7 +331,6 @@ namespace sqlite_orm {
                 std::stringstream ss;
                 ss << C::name();
                 auto name = ss.str();
-                ss.flush();
                 this->create_collation(name, move(func));
             }
 
@@ -343,7 +345,7 @@ namespace sqlite_orm {
 
                 //  create collations if db is open
                 if(this->connection->retain_count() > 0) {
-                    auto db = this->connection->get();
+                    sqlite3* db = this->connection->get();
                     auto resultCode = sqlite3_create_collation(db,
                                                                name.c_str(),
                                                                SQLITE_UTF8,
@@ -360,7 +362,6 @@ namespace sqlite_orm {
                 std::stringstream ss;
                 ss << C::name();
                 auto name = ss.str();
-                ss.flush();
                 this->create_collation(name, {});
             }
 
@@ -381,7 +382,7 @@ namespace sqlite_orm {
             }
 
             void commit() {
-                auto db = this->connection->get();
+                sqlite3* db = this->connection->get();
                 perform_void_exec(db, "COMMIT");
                 this->connection->release();
                 if(this->connection->retain_count() < 0) {
@@ -390,7 +391,7 @@ namespace sqlite_orm {
             }
 
             void rollback() {
-                auto db = this->connection->get();
+                sqlite3* db = this->connection->get();
                 perform_void_exec(db, "ROLLBACK");
                 this->connection->release();
                 if(this->connection->retain_count() < 0) {
@@ -500,7 +501,7 @@ namespace sqlite_orm {
                 if(1 == this->connection->retain_count()) {
                     this->on_open_internal(this->connection->get());
                 }
-                auto db = this->connection->get();
+                sqlite3* db = this->connection->get();
                 perform_void_exec(db, query);
             }
 
@@ -596,7 +597,7 @@ namespace sqlite_orm {
                     it = functionsVector.end();
 
                     if(this->connection->retain_count() > 0) {
-                        auto db = this->connection->get();
+                        sqlite3* db = this->connection->get();
                         auto resultCode = sqlite3_create_function_v2(db,
                                                                      name.c_str(),
                                                                      0,
diff --git a/dev/table_info.h b/dev/table_info.h
index 7046976..3b63035 100644
--- a/dev/table_info.h
+++ b/dev/table_info.h
@@ -2,6 +2,8 @@
 
 #include <string>  //  std::string
 
+#include "start_macros.h"
+
 namespace sqlite_orm {
 
     struct table_info {
@@ -12,6 +14,7 @@ namespace sqlite_orm {
         std::string dflt_value;
         int pk = 0;
 
+#ifndef SQLITE_ORM_AGGREGATE_PAREN_INIT
         table_info(decltype(cid) cid_,
                    decltype(name) name_,
                    decltype(type) type_,
@@ -20,6 +23,7 @@ namespace sqlite_orm {
                    decltype(pk) pk_) :
             cid(cid_),
             name(move(name_)), type(move(type_)), notnull(notnull_), dflt_value(move(dflt_value_)), pk(pk_) {}
+#endif
     };
 
 }
diff --git a/dev/view.h b/dev/view.h
index 204faa0..b695d4d 100644
--- a/dev/view.h
+++ b/dev/view.h
@@ -1,13 +1,12 @@
 #pragma once
 
+#include <sqlite3.h>
 #include <memory>  //  std::shared_ptr
 #include <string>  //  std::string
 #include <utility>  //  std::forward, std::move
-#include <sqlite3.h>
 #include <tuple>  //  std::tuple, std::make_tuple
 
 #include "row_extractor.h"
-#include "statement_finalizer.h"
 #include "error_code.h"
 #include "iterator.h"
 #include "ast_iterator.h"
-- 
2.34.1.windows.1

